##### Q1. 
For a user, the candidate mutual friends are the friends of each of the user's friends. If we have an pair RDD such that 'key' is user, and 'value' is a list of lists of friends for each friend of the user, then the frequency of the ID's in this 'value' will give us the the counts for the mutual friends. We can get such a pair RDD of second-order friends by mapping every line having (user, friend_list) to \[(friend_i, friend_list) for friend_i in friend_list\] (this works because friendship in bidirectional in this case). Note, that we need to ignore the first-order friends while counting. The first order can be generated by mapping every line to [(user, friend_i) for friend_i in friend_list]. Then we can "cogroup" (which groups by 'key' both the RDDs - second-order and first order friends) followed by applying a map function which counts after ignoring first-order friends and sorts the output.

We need to mutual friends in a large system, where number of users ("n") could be so huge that it cannot fit in memory, but the number of friends a user can have ("k") is not so huge, (k << n). I assume that each machine would have enough memory for k^2 user ids. Each machine in this solution would require at most O(k^2) memory, which is the memory taken up an element in the largest RDD.

_The attached code also contains in-line comments._

##### Recommendations for the requested user IDs: <User><TAB><Recommendations>
```
924	439,2409,6995,11860,15416,43748,45881
8941	8943,8944,8940
8942	8939,8940,8943,8944
9019	9022,317,9023
9020	9021,9016,9017,9022,317,9023
9021	9020,9016,9017,9022,317,9023
9022	9019,9020,9021,317,9016,9017,9023
9990	13134,13478,13877,34299,34485,34642,37941
9992	9987,9989,35667,9991
9993	9991,13134,13478,13877,34299,34485,34642,37941
```
